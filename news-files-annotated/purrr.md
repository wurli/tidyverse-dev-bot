# purrr (development version)

!begin-bullets-1!

-   !begin-bullet!
    Requires R \>= 4.1.
    !end-bullet!
-   !begin-bullet!
    purrr gains the capacity for parallel and distributed map, powered
    by the mirai package. Newly-added `in_parallel()` wraps a function
    provided to `map()` and all its variants to enable this. See
    `?in_parallel` for more details (@shikokuchuo, #1163, #1185).
    !end-bullet!

!end-bullets-1!

# purrr 1.0.4

# purrr 1.0.3

!begin-bullets-2!

-   !begin-bullet!
    Varies fixed to bring purrr back into compliance with R CMD check
    (@shikokuchuo, @jayhesselberth).

    !end-bullet!
-   !begin-bullet!
    Added missing `imap_vec()` (#1084)

    !end-bullet!
-   !begin-bullet!
    `list_transpose()` now asserts that it does not work on data frames
    (@KimLopezGuell, #1141, #1149), and inspects all elements to
    determine the correct template if not provided by the user (#1128,
    @krlmlr).

    !end-bullet!

!end-bullets-2!

# purrr 1.0.2

!begin-bullets-3!

-   !begin-bullet!
    Fixed valgrind issue.

    !end-bullet!
-   !begin-bullet!
    Deprecation infrastructure in `map_chr()` now has much less overhead
    leading to improved performance (#1089).

    !end-bullet!
-   !begin-bullet!
    purrr now requires R 3.5.0.

    !end-bullet!

!end-bullets-3!

# purrr 1.0.1

!begin-bullets-4!

-   !begin-bullet!
    As of purrr 1.0.0, the `map()` family of functions wraps all errors
    generated by `.f` inside an wrapper error that tracks the iteration
    index. As of purrr 1.0.1, this error now has a custom class
    (`purrr_error_indexed`), `location` and `name` fields, and is
    documented in `?purrr_error_indexed` (#1027).

    !end-bullet!
-   !begin-bullet!
    `map()` errors with named inputs also report the name of the element
    that errored.

    !end-bullet!
-   !begin-bullet!
    Fixed an issue where progress bars weren't being closed when user
    interrupts or errors were encountered during a `map()` call (#1024).

    !end-bullet!
-   !begin-bullet!
    Fixed an invalid C signature for `pluck()` (#1018).

    !end-bullet!
-   !begin-bullet!
    Set `Biarch: true` to build purrr on 32-bit Windows on R \< 4.2.0
    (#1017).

    !end-bullet!

!end-bullets-4!

# purrr 1.0.0

## Breaking changes

### Core purpose refinements

!begin-bullets-5!

-   !begin-bullet!
    `cross()` and all its variants have been deprecated in favour of
    `tidyr::expand_grid()`. These functions were slow and buggy and we
    no longer think they are the right approach to solving this problem.
    See #768 for more information.

    !end-bullet!
-   !begin-bullet!
    `update_list()` (#858) and `rerun()` (#877), and the use of
    tidyselect with `map_at()` and friends (#874) have been deprecated.
    These functions use some form of non-standard evaluation which we
    now believe is a poor fit for purrr.

    !end-bullet!
-   !begin-bullet!
    The `lift_*` family of functions has been deprecated. We no longer
    believe these to be a good fit for purrr because they rely on a
    style of function manipulation that is very uncommon in R code
    (#871).

    !end-bullet!
-   !begin-bullet!
    `prepend()`, `rdunif()`, `rbernoulli()`, `when()`, and
    `list_along()` have all been deprecated (#925). It's now clear that
    they don't align with the core purpose of purrr.

    !end-bullet!
-   !begin-bullet!
    `splice()` is deprecated because we no longer believe that automatic
    splicing makes for good UI. Instead use `list2()` + `!!!` or
    `list_flatten()` (#869).

    !end-bullet!

!end-bullets-5!

### Mapping

!begin-bullets-6!

-   !begin-bullet!
    Use of map functions with expressions, calls, and pairlists has been
    deprecated (#961).

    !end-bullet!
-   !begin-bullet!
    All map `_raw()` variants have been deprecated because they are of
    limited use and you can now use `map_vec()` instead (#903).

    !end-bullet!
-   !begin-bullet!
    In `map_chr()`, automatic conversion from logical, integer, and
    double to character is now deprecated. Use an explicit
    `as.character()` if needed (#904).

    !end-bullet!
-   !begin-bullet!
    Errors from `.f` are now wrapped in an additional class that gives
    information about where the error occurred (#945).

    !end-bullet!

!end-bullets-6!

### Deprecation next steps

!begin-bullets-7!

-   !begin-bullet!
    `as_function()` and the `...f` argument to `partial()` are no longer
    supported. They have been defunct for quite some time.

    !end-bullet!
-   !begin-bullet!
    Soft deprecated functions: `%@%`, `reduce_right()`,
    `reduce2_right()`, `accumulate_right()` are now fully deprecated.
    Similarly, the `.lazy`, `.env`, and `.first` arguments to
    `partial()`, and the `.right` argument to `detect()` and
    `detect_index()` are fully deprecated. Removing elements with `NULL`
    in `list_modify()` and `list_merge()` is now fully deprecated.

    !end-bullet!
-   !begin-bullet!
    `is_numeric()` and `is_scalar_numeric()` have been removed. They
    have been deprecated since purrr 0.2.3 (Sep 2017).

    !end-bullet!
-   !begin-bullet!
    `invoke_*()` is now deprecated. It was superseded in 0.3.0
    (Jan 2019) and 3.5 years later, we have decided to deprecate it as
    part of the API refinement in the 1.0.0 release.

    !end-bullet!
-   !begin-bullet!
    `map_call()` has been removed. It was made defunct in 0.3.0 (Jan
    2019).

    !end-bullet!

!end-bullets-7!

## New features

!begin-bullets-8!

-   !begin-bullet!
    `*_at()` can now take a function (or formula) that's passed the
    vector of element names and returns the elements to select.

    !end-bullet!
-   !begin-bullet!
    New `map_vec()`, `map2_vec()`, and `pmap_vec()` work on all types of
    vectors, extending `map_lgl()`, `map_int()`, and friends so that you
    can easily work with dates, factors, date-times and more (#435).

    !end-bullet!
-   !begin-bullet!
    New `keep_at()` and `discard_at()` that work like `keep()` and
    `discard()` but operation on element names rather than element
    contents (#817).

    !end-bullet!
-   !begin-bullet!
    Some mapping functions have now a `.progress` argument to create a
    progress bar. See `?progress_bars` (#149).

    !end-bullet!
-   !begin-bullet!
    purrr is now licensed as MIT (#805).

    !end-bullet!
-   !begin-bullet!
    `modify()`, `modify_if()`, `modify_at()`, and `modify2()` are no
    longer generics. We have discovered a simple implementation that no
    longer requires genericity and methods were only provided by a very
    small number of packages (#894).

    !end-bullet!
-   !begin-bullet!
    purrr now uses the base pipe (`|>`) and anonymous function short
    hand (`\(x)`), in all examples. This means that examples will no
    longer work in R 4.0 and earlier so in those versions of R, the
    examples are automatically converted to a regular section with a
    note that they might not work (#936).

    !end-bullet!
-   !begin-bullet!
    When map functions fail, they now report the element they failed at
    (#945).

    !end-bullet!
-   !begin-bullet!
    New `modify_tree()` for recursively modifying nested data structures
    (#720).

    !end-bullet!

!end-bullets-8!

### Flattening and simplification

!begin-bullets-9!

-   !begin-bullet!
    New `list_c()`, `list_rbind()`, and `list_cbind()` make it easy to
    `c()`, `rbind()`, or `cbind()` all of the elements in a list.

    !end-bullet!
-   !begin-bullet!
    New `list_simplify()` reduces a list of length-1 vectors to a
    simpler atomic or S3 vector (#900).

    !end-bullet!
-   !begin-bullet!
    New `list_transpose()` which automatically simplifies if possible
    (#875).

    !end-bullet!
-   !begin-bullet!
    `accumulate()` and `accumulate2()` now both simplify the output if
    possible using vctrs. New arguments `simplify` and `ptype` allow you
    to control the details of simplification (#774, #809).

    !end-bullet!
-   !begin-bullet!
    `flatten()` and friends are superseded in favour of
    `list_flatten()`, `list_c()`, `list_cbind()`, and `list_rbind()`.

    !end-bullet!
-   !begin-bullet!
    `*_dfc()` and `*_dfr()` have been superseded in favour of using the
    appropriate map function along with `list_rbind()` or `list_cbind()`
    (#912).

    !end-bullet!
-   !begin-bullet!
    `simplify()`, `simplify_all()`, and `as_vector()` have been
    superseded in favour of `list_simplify()`. It provides a more
    consistent definition of simplification (#900).

    !end-bullet!
-   !begin-bullet!
    `transpose()` has been superseded in favour of `list_transpose()`
    (#875). It has built-in simplification.

    !end-bullet!

!end-bullets-9!

### Tidyverse consistency

!begin-bullets-10!

-   !begin-bullet!
    `_lgl()`, `_int()`, `_int()`, and `_dbl()` now use the same (strict)
    coercion methods as vctrs (#904). This means that:

    !begin-bullets-11!
    -   !begin-bullet!
        `map_chr(TRUE, identity)`, `map_chr(0L, identity)`, and
        `map_chr(1L, identity)` are deprecated because we now believe
        that converting a logical/integer/double to a character vector
        should require an explicit coercion.

        !end-bullet!
    -   !begin-bullet!
        `map_int(1.5, identity)` now fails because we believe that
        silently truncating doubles to integers is dangerous. But note
        that `map_int(1, identity)` still works since no numeric
        precision is lost.

        !end-bullet!
    -   !begin-bullet!
        `map_int(c(TRUE, FALSE), identity)`,
        `map_dbl(c(TRUE, FALSE), identity)`,
        `map_lgl(c(1L, 0L), identity)` and `map_lgl(c(1, 0), identity)`
        now succeed because 1/TRUE and 0/FALSE should be
        interchangeable.

        !end-bullet!

    !end-bullets-11!
    !end-bullet!
-   !begin-bullet!
    `map2()`, `modify2()`, and `pmap()` now use tidyverse recycling
    rules where vectors of length 1 are recycled to any size but all
    others must have the same length (#878).

    !end-bullet!
-   !begin-bullet!
    `map2()` and `pmap()` now recycle names of their first input if
    needed (#783).

    !end-bullet!
-   !begin-bullet!
    `modify()`, `modify_if()`, and `modify_at()` have been reimplemented
    using vctrs principles. This shouldn't have an user facing impact,
    but it does make the implementation much simpler.

    !end-bullet!

!end-bullets-10!

### Plucking

!begin-bullets-12!

-   !begin-bullet!
    `vec_depth()` is now `pluck_depth()` and works with more types of
    input (#818).

    !end-bullet!
-   !begin-bullet!
    `pluck()` now requires indices to be length 1 (#813). It also now
    reports the correct type if you supply an unexpected index.

    !end-bullet!
-   !begin-bullet!
    `pluck()` now accepts negative integers, indexing from the right
    (#603).

    !end-bullet!
-   !begin-bullet!
    `pluck()` and `chuck()` now fail if you provide named inputs to ...
    (#788).

    !end-bullet!
-   !begin-bullet!
    `pluck()` no longer replaces 0-length vectors with `default`; it now
    only applies absent and `NULL` components (#480).

    !end-bullet!
-   !begin-bullet!
    `pluck<-`/`assign_in()` can now modify non-existing locations
    (#704).

    !end-bullet!

!end-bullets-12!

### Setting with NULL

!begin-bullets-13!

-   !begin-bullet!
    `pluck<-`/`assign_in()` now sets elements to `NULL` rather than
    removing them (#636). Now use the explicit `zap()` if you want to
    remove elements.

    !end-bullet!
-   !begin-bullet!
    `modify()`, `modify2()`, and `modify_if()` now correctly handle
    `NULL`s in replacement values (#655, #746, #753).

    !end-bullet!
-   !begin-bullet!
    `list_modify()`'s interface has been standardised. Modifying with
    `NULL` now always creates a `NULL` in the output (#810)

    !end-bullet!

!end-bullets-13!

### `list_` functions

!begin-bullets-14!

-   !begin-bullet!
    New `list_assign()` which is similar to `list_modify()` but doesn't
    work recursively (#822).

    !end-bullet!
-   !begin-bullet!
    `list_modify()` no longer recurses into data frames (and other
    objects built on top of lists that are fundamentally non-list like)
    (#810). You can revert to the previous behaviour by setting
    `.is_node = is.list`.

    !end-bullet!

!end-bullets-14!

## Minor improvements and bug fixes

!begin-bullets-15!

-   !begin-bullet!
    `capture_output()` correctly uses `conditionMessage()` instead of
    directly interrogating the `message` field (#1010).

    !end-bullet!
-   !begin-bullet!
    `modify()` no longer works with calls or pairlists.

    !end-bullet!
-   !begin-bullet!
    `modify_depth()` is no longer a generic. This makes it more
    consistent with `map_depth()`.

    !end-bullet!
-   !begin-bullet!
    `map_depth()` and `modify_depth()` have a new `is_node` argument
    that allows you to control what counts as a level. The default uses
    `vec_is_list()` to avoid recursing into rich S3 objects like linear
    models or data.frames (#958, #920).

    !end-bullet!
-   !begin-bullet!
    `map_depth()` and `modify_depth()` now correctly recurse at depth 1.

    !end-bullet!
-   !begin-bullet!
    `as_mapper()` is now around twice as fast when used with character,
    integer, or list (#820).

    !end-bullet!
-   !begin-bullet!
    `possibly()` now defaults `otherwise` to NULL.

    !end-bullet!
-   !begin-bullet!
    `modify_if(.else)` is now actually evaluated for atomic vectors
    (@mgirlich, #701).

    !end-bullet!
-   !begin-bullet!
    `lmap_if()` correctly handles `.else` functions (#847).

    !end-bullet!
-   !begin-bullet!
    `every()` now correctly propagates missing values using the same
    rules as `&&` (#751). Internally, it has become a wrapper around
    `&&`. This makes it consistent with `&&` and also with `some()`
    which has always been a wrapper around `||` with the same
    propagation rules.

    !end-bullet!
-   !begin-bullet!
    `every()` and `some()` now properly check the return value of their
    predicate function. It must now return a `TRUE`, `FALSE`, or `NA`.

    !end-bullet!
-   !begin-bullet!
    Greatly improved performance of functions created with `partial()`
    (#715). Their invocation is now as fast as for functions creating
    manually.

    !end-bullet!
-   !begin-bullet!
    `partial()` no longer inlines the function in the call stack. This
    fixes issues when `partial()` is used with `lm()` for instance
    (#707).

    !end-bullet!

!end-bullets-15!

# purrr 0.3.5

!begin-bullets-16!

-   !begin-bullet!
    Fixes for CRAN checks.
    !end-bullet!

!end-bullets-16!

# purrr 0.3.4

!begin-bullets-17!

-   !begin-bullet!
    Fixed issue in `list_modify()` that prevented lists from being
    removed with `zap()` (@adamroyjones, #777).

    !end-bullet!
-   !begin-bullet!
    Added documentation for exporting functions created with purrr
    adverb (@njtierney, #668). See `?faq-adverbs-export`.

    !end-bullet!
-   !begin-bullet!
    Added `none()`, which tests that a predicate is false for all
    elements (the opposite of `every()`) (@AliciaSchep, #735).

    !end-bullet!

!end-bullets-17!

# purrr 0.3.3

!begin-bullets-18!

-   !begin-bullet!
    Maintenance release.

    !end-bullet!
-   !begin-bullet!
    The documentation of `map()` and its variants has been improved by
    @surdina as part of the Tidyverse Developer Day (@surdina, #671).

    !end-bullet!
-   !begin-bullet!
    purrr now depends on R 3.2 or greater.

    !end-bullet!

!end-bullets-18!

# purrr 0.3.2

!begin-bullets-19!

-   !begin-bullet!
    Fix protection issues reported by rchk.
    !end-bullet!

!end-bullets-19!

# purrr 0.3.1

!begin-bullets-20!

-   !begin-bullet!
    `reduce()` now forces arguments (#643).

    !end-bullet!
-   !begin-bullet!
    Fixed an issue in `partial()` with generic functions (#647).

    !end-bullet!
-   !begin-bullet!
    `negate()` now works with generic functions and functions with early
    returns.

    !end-bullet!
-   !begin-bullet!
    `compose()` now works with generic functions again (#629, #639). Its
    set of unit tests was expanded to cover many edge cases.

    !end-bullet!
-   !begin-bullet!
    `prepend()` now works with empty lists (@czeildi, #637)

    !end-bullet!

!end-bullets-20!

# purrr 0.3.0

## Breaking changes

!begin-bullets-21!

-   !begin-bullet!
    `modify()` and variants are now wrapping `[[<-` instead of `[<-`.
    This change increases the genericity of these functions but might
    cause different behaviour in some cases.

    For instance, the `[[<-` for data frames is stricter than the `[<-`
    method and might throw errors instead of warnings. This is the case
    when assigning a longer vector than the number of rows. `[<-`
    truncates the vector with a warning, `[[<-` fails with an error (as
    is appropriate).

    !end-bullet!
-   !begin-bullet!
    `modify()` and variants now return the same type as the input when
    the input is an atomic vector.

    !end-bullet!
-   !begin-bullet!
    All functionals taking predicate functions (like `keep()`,
    `detect()`, `some()`) got stricter. Predicate functions must now
    return a single `TRUE` or `FALSE`.

    This change is meant to detect problems early with a more meaningful
    error message.

    !end-bullet!

!end-bullets-21!

## Plucking

!begin-bullets-22!

-   !begin-bullet!
    New `chuck()` function. This is a strict variant of `pluck()` that
    throws errors when an element does not exist instead of returning
    `NULL` (@daniel-barnett, #482).

    !end-bullet!
-   !begin-bullet!
    New `assign_in()` and `pluck<-` functions. They modify a data
    structure at an existing pluck location.

    !end-bullet!
-   !begin-bullet!
    New `modify_in()` function to map a function at a pluck location.

    !end-bullet!
-   !begin-bullet!
    `pluck()` now dispatches properly with S3 vectors. The vector class
    must implement a `length()` method for numeric indexing and a
    `names()` method for string indexing.

    !end-bullet!
-   !begin-bullet!
    `pluck()` now supports primitive functions (#404).

    !end-bullet!

!end-bullets-22!

## Mapping

!begin-bullets-23!

-   !begin-bullet!
    New `.else` argument for `map_if()` and `modify_if()`. They take an
    alternative function that is mapped over elements of the input for
    which the predicate function returns `FALSE` (#324).

    !end-bullet!
-   !begin-bullet!
    `reduce()`, `reduce2()`, `accumulate()`, and `accumulate2()` now
    terminate early when the function returns a value wrapped with
    `done()` (#253). When an empty `done()` is returned, the value at
    the last iteration is returned instead.

    !end-bullet!
-   !begin-bullet!
    Functions taking predicates (`map_if()`, `keep()`, `some()`,
    `every()`, `keep()`, etc) now fail with an informative message when
    the return value is not `TRUE` or `FALSE` (#470).

    This is a breaking change for `every()` and `some()` which were
    documented to be more liberal in the values they accepted as logical
    (any vector was considered `TRUE` if not a single `FALSE` value, no
    matter its length). These functions signal soft-deprecation warnings
    instead of a hard failure.

    Edit (purr 0.4.0): `every()` and `some()` never issued deprecation
    warnings because of a technical issue. We didn't fix the warnings in
    the end, and using predicates returning `NA` is no longer considered
    deprecated. If you need to use `every()` and `some()` in contexts
    where `NA` propagation is unsafe, e.g. in `if ()` conditions, make
    sure to use safe predicate functions like `is_true()`.

    !end-bullet!
-   !begin-bullet!
    `modify()` and variants are now implemented using `length()`, `[[`,
    and `[[<-` methods. This implementation should be compatible with
    most vector classes.

    !end-bullet!
-   !begin-bullet!
    New `modify2()` and `imodify()` functions. These work like `map()`
    and `imap()` but preserve the type of `.x` in the return value.

    !end-bullet!
-   !begin-bullet!
    `pmap()` and `pwalk()` now preserve class for inputs of `factor`,
    `Date`, `POSIXct` and other atomic S3 classes with an appropriate
    `[[` method (#358, @mikmart).

    !end-bullet!
-   !begin-bullet!
    `modify()`, `modify_if()` and `modify_at()` now preserve the class
    of atomic vectors instead of promoting them to lists. New S3 methods
    are provided for character, logical, double, and integer classes
    (@t-kalinowski, #417).

    !end-bullet!
-   !begin-bullet!
    By popular request, `at_depth()` has been brought back as
    `map_depth()`. Like `modify_depth()`, it applies a function at a
    specified level of a data structure. However, it transforms all
    traversed vectors up to `.depth` to bare lists (#381).

    !end-bullet!
-   !begin-bullet!
    `map_at()`, `modify_at()` and `lmap_at()` accept negative values for
    `.at`, ignoring elements at those positions.

    !end-bullet!
-   !begin-bullet!
    `map()` and `modify()` now work with calls and pairlists (#412).

    !end-bullet!
-   !begin-bullet!
    `modify_depth()` now modifies atomic leaves as well. This makes
    `modify_depth(x, 1, fn)` equivalent to `modify(x, fn)` (#359).

    !end-bullet!
-   !begin-bullet!
    New `accumulate2()` function which is to `accumulate()` what
    `reduce2()` is to `reduce()`.

    !end-bullet!

!end-bullets-23!

## Rates

!begin-bullets-24!

-   !begin-bullet!
    New `rate_backoff()` and `rate_delay()` functions to create rate
    objects. You can pass rates to `insistently()`, `slowly()`, or the
    lower level function `rate_sleep()`. This will cause a function to
    wait for a given amount of time with exponential backoff
    (increasingly larger waiting times) or for a constant delay.

    !end-bullet!
-   !begin-bullet!
    `insistently(f)` modifies a function, `f`, so that it is repeatedly
    called until it succeeds (@richierocks, @ijlyttle).

    `slowly()` modifies a function so that it waits for a given amount
    of time between calls.

    !end-bullet!

!end-bullets-24!

## `partial()`

The interface of `partial()` has been simplified. It now supports
quasiquotation to control the timing of evaluation, and the
`rlang::call_modify()` syntax to control the position of partialised
arguments.

!begin-bullets-25!

-   !begin-bullet!
    `partial()` now supports empty `... =` argument to specify the
    position of future arguments, relative to partialised ones. This
    syntax is borrowed from (and implemented with)
    `rlang::call_modify()`.

    To prevent partial matching of `...` on `...f`, the latter has been
    renamed to `.f`, which is more consistent with other purrr function
    signatures.

    !end-bullet!
-   !begin-bullet!
    `partial()` now supports quasiquotation. When you unquote an
    argument, it is evaluated only once at function creation time. This
    is more flexible than the `.lazy` argument since you can control the
    timing of evaluation for each argument. Consequently, `.lazy` is
    soft-deprecated (#457).

    !end-bullet!
-   !begin-bullet!
    Fixed an infinite loop when partialised function is given the same
    name as the original function (#387).

    !end-bullet!
-   !begin-bullet!
    `partial()` now calls `as_closure()` on primitive functions to
    ensure argument matching (#360).

    !end-bullet!
-   !begin-bullet!
    The `.lazy` argument of `partial()` is soft-deprecated in favour of
    quasiquotation:

    !begin-codeblock!
    ``` r
    # Before
    partial(fn, u = runif(1), n = rnorm(1), .lazy = FALSE)

    # After
    partial(fn, u = !!runif(1), n = !!rnorm(1))  # All constant
    partial(fn, u = !!runif(1), n = rnorm(1))    # First constant
    ```

    !end-codeblock!
    !end-bullet!

!end-bullets-25!

## Minor improvements and fixes

!begin-bullets-26!

-   !begin-bullet!
    The tibble package is now in Suggests rather than Imports. This
    brings the hard dependency of purrr to just rlang and magrittr.

    !end-bullet!
-   !begin-bullet!
    `compose()` now returns an identity function when called without
    inputs.

    !end-bullet!
-   !begin-bullet!
    Functions created with `compose()` now have the same formal
    parameters as the first function to be called. They also feature a
    more informative print method that prints all composed functions in
    turn (@egnha, #366).

    !end-bullet!
-   !begin-bullet!
    New `.dir` argument in `compose()`. When set to `"forward"`, the
    functions are composed from left to right rather than right to left.

    !end-bullet!
-   !begin-bullet!
    `list_modify()` now supports the `zap()` sentinel (reexported from
    rlang) to remove elements from lists. Consequently, removing
    elements with the ambiguous sentinel `NULL` is soft-deprecated.

    !end-bullet!
-   !begin-bullet!
    The requirements of `list_modify()` and `list_merge()` have been
    relaxed. Previously it required both the modified lists and the
    inputs to be either named or unnamed. This restriction now only
    applies to inputs in `...`. When inputs are all named, they are
    matched to the list by name. When they are all unnamed, they are
    matched positionally. Otherwise, this is an error.

    !end-bullet!
-   !begin-bullet!
    Fixed ordering of names returned by `accumulate_right()` output.
    They now correspond to the order of inputs.

    !end-bullet!
-   !begin-bullet!
    Fixed names of `accumulate()` output when `.init` is supplied.

    !end-bullet!
-   !begin-bullet!
    `compose()` now supports composition with lambdas (@ColinFay, #556)

    !end-bullet!
-   !begin-bullet!
    Fixed a `pmap()` crash with empty lists on the Win32 platform
    (#565).

    !end-bullet!
-   !begin-bullet!
    `modify_depth` now has `.ragged` argument evaluates correctly to
    `TRUE` by default when `.depth < 0` (@cderv, #530).

    !end-bullet!
-   !begin-bullet!
    `accumulate()` now inherits names from their first input (@AshesITR,
    #446).

    !end-bullet!
-   !begin-bullet!
    `attr_getter()` no longer uses partial matching. For example, if an
    `x` object has a `labels` attribute but no `label` attribute,
    `attr_getter("label")(x)` will no longer extract the `labels`
    attribute (#460, @huftis).

    !end-bullet!
-   !begin-bullet!
    `flatten_dfr()` and `flatten_dfc()` now aborts if dplyr is not
    installed. (#454)

    !end-bullet!
-   !begin-bullet!
    `imap_dfr()` now works with `.id` argument is provided (#429)

    !end-bullet!
-   !begin-bullet!
    `list_modify()`, `update_list()` and `list_merge()` now handle
    duplicate duplicate argument names correctly (#441, @mgirlich).

    !end-bullet!
-   !begin-bullet!
    `map_raw`, `imap_raw`, `flatten_raw`, `invoke_map_raw`, `map2_raw`
    and `pmap_raw` added to support raw vectors. (#455, @romainfrancois)

    !end-bullet!
-   !begin-bullet!
    `flatten()` now supports raw and complex elements.

    !end-bullet!
-   !begin-bullet!
    `array_branch()` and `array_tree()` now retain the `dimnames()` of
    the input array (#584, @flying-sheep)

    !end-bullet!
-   !begin-bullet!
    `pluck()` no longer flattens lists of arguments. You can still do it
    manually with `!!!`. This change is for consistency with other
    dots-collecting functions of the tidyverse.

    !end-bullet!
-   !begin-bullet!
    `map_at()`, `lmap_at()` and `modify_at()` now supports selection
    using `vars()` and `tidyselect` (@ColinFay, #608).

    Note that for now you need to import `vars()` from dplyr or call it
    qualified like `dplyr::vars()`. It will be reexported from rlang in
    a future release.

    !end-bullet!
-   !begin-bullet!
    `detect()` now has a .default argument to specify the value returned
    when nothing is detected (#622, @ColinFay).

    !end-bullet!

!end-bullets-26!

## Life cycle

### `.dir` arguments

We have standardised the purrr API for reverse iteration with a common
`.dir` argument.

!begin-bullets-27!

-   !begin-bullet!
    `reduce_right()` is soft-deprecated and replaced by a new `.dir`
    argument of `reduce()`:

    !begin-codeblock!
    ``` {r}
    # Before:
    reduce_right(1:3, f)

    # After:
    reduce(1:3, f, .dir = "backward")
    ```

    !end-codeblock!
    Note that the details of the computation have changed. Whereas
    `reduce_right()` computed `f(f(3, 2), 1)`, it now computes
    `f(1, f(2, 3))`. This is the standard way of reducing from the
    right.

    To produce the exact same reduction as `reduce_right()`, simply
    reverse your vector and use a left reduction:

    !begin-codeblock!
    ``` {r}
    # Before:
    reduce_right(1:3, f)

    # After:
    reduce(rev(1:3), f)
    ```

    !end-codeblock!
    !end-bullet!
-   !begin-bullet!
    `reduce2_right()` is soft-deprecated without replacement. It is not
    clear what algorithmic properties should a right reduction have in
    this case. Please reach out if you know about a use case for a right
    reduction with a ternary function.

    !end-bullet!
-   !begin-bullet!
    `accumulate_right()` is soft-deprecated and replaced by the new
    `.dir` argument of `accumulate()`. Note that the algorithm has
    slightly changed: the accumulated value is passed to the right
    rather than the left, which is consistent with a right reduction.

    !begin-codeblock!
    ``` {r}
    # Before:
    accumulate_right(1:3, f)

    # After:
    accumulate(1:3, f, .dir = "backward")
    ```

    !end-codeblock!
    !end-bullet!
-   !begin-bullet!
    The `.right` argument of `detect()` and `detect_index()` is
    soft-deprecated and renamed to `.dir` for consistency with other
    functions and clarity of the interface.

    !begin-codeblock!
    ``` {r}
    # Before
    detect(x, f, .right = TRUE)

    # After
    detect(x, f, .dir = "backward")
    ```

    !end-codeblock!
    !end-bullet!

!end-bullets-27!

### Simplification of `partial()`

The interface of `partial()` has been simplified (see more about
`partial()` below):

!begin-bullets-28!

-   !begin-bullet!
    The `.lazy` argument of `partial()` is soft-deprecated in favour of
    quasiquotation.

    !end-bullet!
-   !begin-bullet!
    We had to rename `...f` to `.f` in `partial()` in order to support
    `... =` argument (which would otherwise partial-match on `...f`).
    This also makes `partial()` more consistent with other purrr
    function signatures.

    !end-bullet!

!end-bullets-28!

### Retirement of `invoke()`

`invoke()` and `invoke_map()` are retired in favour of `exec()`. Note
that retired functions are no longer under active development, but
continue to be maintained undefinitely in the package.

!begin-bullets-29!

-   !begin-bullet!
    `invoke()` is retired in favour of the `exec()` function, reexported
    from rlang. `exec()` evaluates a function call built from its inputs
    and supports tidy dots:

    !begin-codeblock!
    ``` r
    # Before:
    invoke(mean, list(na.rm = TRUE), x = 1:10)

    # After
    exec(mean, 1:10, !!!list(na.rm = TRUE))
    ```

    !end-codeblock!
    Note that retired functions are not removed from the package and
    will be maintained undefinitely.

    !end-bullet!
-   !begin-bullet!
    `invoke_map()` is retired without replacement because it is more
    complex to understand than the corresponding code using `map()`,
    `map2()` and `exec()`:

    !begin-codeblock!
    ``` r
    # Before:
    invoke_map(fns, list(args))
    invoke_map(fns, list(args1, args2))

    # After:
    map(fns, exec, !!!args)
    map2(fns, list(args1, args2), function(fn, args) exec(fn, !!!args))
    ```

    !end-codeblock!
    !end-bullet!

!end-bullets-29!

### Other lifecycle changes

!begin-bullets-30!

-   !begin-bullet!
    `%@%` is soft-deprecated, please use the operator exported in rlang
    instead. The latter features an interface more consistent with `@`
    as it uses NSE, supports S4 fields, and has an assignment variant.

    !end-bullet!
-   !begin-bullet!
    Removing elements from lists using `NULL` in `list_modify()` is
    soft-deprecated. Please use the new `zap()` sentinel reexported from
    rlang instead:

    !begin-codeblock!
    ``` {r}
      # Before:
      list_modify(x, foo = NULL)

      # After:
      list_modify(x, foo = zap())
    ```

    !end-codeblock!
    This change is motivated by the ambiguity of `NULL` as a deletion
    sentinel because `NULL` is also a valid value in lists. In the
    future, `NULL` will set an element to `NULL` rather than removing
    the element.

    !end-bullet!
-   !begin-bullet!
    `rerun()` is now in the questioning stage because we are no longer
    convinced NSE functions are a good fit for purrr. Also,
    `rerun(n,   x)` can just as easily be expressed as `map(1:n, ~ x)`
    (with the added benefit of being passed the current index as
    argument to the lambda).

    !end-bullet!
-   !begin-bullet!
    `map_call()` is defunct.

    !end-bullet!

!end-bullets-30!

# purrr 0.2.5

!begin-bullets-31!

-   !begin-bullet!
    This is a maintenance release following the release of dplyr 0.7.5.
    !end-bullet!

!end-bullets-31!

# purrr 0.2.4

!begin-bullets-32!

-   !begin-bullet!
    Fixes for R 3.1.
    !end-bullet!

!end-bullets-32!

# purrr 0.2.3

## Breaking changes

We noticed the following issues during reverse dependencies checks:

!begin-bullets-33!

-   !begin-bullet!
    If `reduce()` fails with this message:
    `` Error: `.x` is empty, and   no `.init` supplied ``, this is
    because `reduce()` now returns `.init` when `.x` is empty. Fix the
    problem by supplying an appropriate argument to `.init`, or by
    providing special behaviour when `.x` has length 0.

    !end-bullet!
-   !begin-bullet!
    The type predicates have been migrated to rlang. Consequently the
    `bare-type-predicates` documentation topic is no longer in purrr,
    which might cause a warning if you cross-reference it.

    !end-bullet!

!end-bullets-33!

## Dependencies

purrr no longer depends on lazyeval or Rcpp (or dplyr, as of the
previous version). This makes the dependency graph of the tidyverse
simpler, and makes purrr more suitable as a dependency of lower-level
packages.

There have also been two changes to eliminate name conflicts between
purrr and dplyr:

!begin-bullets-34!

-   !begin-bullet!
    `order_by()`, `sort_by()` and `split_by()` have been removed.
    `order_by()` conflicted with `dplyr::order_by()` and the complete
    family doesn't feel that useful. Use tibbles instead (#217).

    !end-bullet!
-   !begin-bullet!
    `contains()` has been renamed to `has_element()` to avoid conflicts
    with dplyr (#217).

    !end-bullet!

!end-bullets-34!

## pluck()

The plucking mechanism used for indexing into data structures with
`map()` has been extracted into the function `pluck()`. Plucking is
often more readable to extract an element buried in a deep data
structure. Compare this syntax-heavy extraction which reads
non-linearly:

!begin-codeblock!

    accessor(x[[1]])$foo

!end-codeblock!

to the equivalent pluck:

!begin-codeblock!

    x |> pluck(1, accessor, "foo")

!end-codeblock!

## Map helpers

!begin-bullets-35!

-   !begin-bullet!
    `as_function()` is now `as_mapper()` because it is a tranformation
    that makes sense primarily for mapping functions, not in general
    (#298). `.null` has been renamed to `.default` to better reflect its
    intent (#298). `.default` is returned whenever an element is absent
    or empty (#231, #254).

    `as_mapper()` sanitises primitive functions by transforming them to
    closures with standardised argument names (using
    `rlang::as_closure()`). For instance `+` is transformed to
    `function(.x, .y) .x + .y`. This results in proper argument matching
    so that `map(1:10, partial(`-`, .x = 5))` produces
    `list(5 - 1, 5 - 2, ...)`.

    !end-bullet!
-   !begin-bullet!
    Recursive indexing can now extract objects out of environments
    (#213) and S4 objects (#200), as well as lists.

    !end-bullet!
-   !begin-bullet!
    `attr_getter()` makes it possible to extract from attributes like
    `map(list(iris, mtcars), attr_getter("row.names"))`.

    !end-bullet!
-   !begin-bullet!
    The argument list for formula-functions has been tweaked so that you
    can refer to arguments by position with `..1`, `..2`, and so on.
    This makes it possible to use the formula shorthand for functions
    with more than two arguments (#289).

    !end-bullet!
-   !begin-bullet!
    `possibly()`, `safely()` and friends no longer capture interrupts:
    this means that you can now terminate a mapper using one of these
    with Escape or Ctrl + C (#314)

    !end-bullet!

!end-bullets-35!

## Map functions

!begin-bullets-36!

-   !begin-bullet!
    All map functions now treat `NULL` the same way as an empty vector
    (#199), and return an empty vector if any input is an empty vector.

    !end-bullet!
-   !begin-bullet!
    All `map()` functions now force their arguments in the same way that
    base R does for `lapply()` (#191). This makes `map()` etc easier to
    use when generating functions.

    !end-bullet!
-   !begin-bullet!
    A new family of "indexed" map functions, `imap()`, `imap_lgl()` etc,
    provide a short-hand for `map2(x, names(x))` or
    `map2(x, seq_along(x))` (#240).

    !end-bullet!
-   !begin-bullet!
    The data frame suffix `_df` has been (soft) deprecated in favour of
    `_dfr` to more clearly indicate that it's a row-bind. All variants
    now also have a `_dfc` for column binding (#167). (These will not be
    terribly useful until `dplyr::bind_rows()`/`dplyr::bind_cols()` have
    better semantics for vectors.)

    !end-bullet!

!end-bullets-36!

## Modify functions

A new `modify()` family returns the same output of the type as the input
`.x`. This is in contrast to the `map()` family which always returns a
list, regardless of the input type.

The modify functions are S3 generics. However their default methods
should be sufficient for most classes since they rely on the semantics
of `[<-`. `modify.default()` is thus a shorthand for `x[] <- map(x, f)`.

!begin-bullets-37!

-   !begin-bullet!
    `at_depth()` has been renamed to `modify_depth()`.

    !end-bullet!
-   !begin-bullet!
    `modify_depth()` gains new `.ragged` argument, and negative depths
    are now computed relative to the deepest component of the list
    (#236).

    !end-bullet!

!end-bullets-37!

## New functions

!begin-bullets-38!

-   !begin-bullet!
    `auto_browse(f)` returns a new function that automatically calls
    `browser()` if `f` throws an error (#281).

    !end-bullet!
-   !begin-bullet!
    `vec_depth()` computes the depth (i.e. the number of levels of
    indexing) or a vector (#243).

    !end-bullet!
-   !begin-bullet!
    `reduce2()` and `reduce2_right()` make it possible to reduce with a
    3 argument function where the first argument is the accumulated
    value, the second argument is `.x`, and the third argument is `.y`
    (#163).

    !end-bullet!
-   !begin-bullet!
    `list_modify()` extends `stats::modifyList()` to replace by position
    if the list is not named.(#201). `list_merge()` operates similarly
    to `list_modify()` but combines instead of replacing (#322).

    !end-bullet!
-   !begin-bullet!
    The legacy function `update_list()` is basically a version of
    `list_modify` that evaluates formulas within the list. It is likely
    to be deprecated in the future in favour of a tidyeval interface
    such as a list method for `dplyr::mutate()`.

    !end-bullet!

!end-bullets-38!

## Minor improvements and bug fixes

!begin-bullets-39!

-   !begin-bullet!
    Thanks to @dchiu911, the unit test coverage of purrr is now much
    greater.

    !end-bullet!
-   !begin-bullet!
    All predicate functions are re-exported from rlang (#124).

    !end-bullet!
-   !begin-bullet!
    `compact()` now works with standard mapper conventions (#282).

    !end-bullet!
-   !begin-bullet!
    `cross_n()` has been renamed to `cross()`. The `_n` suffix was
    removed for consistency with `pmap()` (originally called `map_n()`
    at the start of the project) and `transpose()` (originally called
    `zip_n()`). Similarly, `cross_d()` has been renamed to `cross_df()`
    for consistency with `map_df()`.

    !end-bullet!
-   !begin-bullet!
    `every()` and `some()` now return `NA` if present in the input
    (#174).

    !end-bullet!
-   !begin-bullet!
    `invoke()` uses a more robust approach to generate the argument list
    (#249) It no longer uses lazyeval to figure out which enviroment a
    character `f` comes from.

    !end-bullet!
-   !begin-bullet!
    `is_numeric()` and `is_scalar_numeric()` are deprecated because they
    don't test for what you might expect at first sight.

    !end-bullet!
-   !begin-bullet!
    `reduce()` now throws an error if `.x` is empty and `.init` is not
    supplied.

    !end-bullet!
-   !begin-bullet!
    Deprecated functions `flatmap()`, `map3()`, `map_n()`, `walk3()`,
    `walk_n()`, `zip2()`, `zip3()`, `zip_n()` have been removed.

    !end-bullet!
-   !begin-bullet!
    `pmap()` coerces data frames to lists to avoid the expensive
    `[.data.frame` which provides security that is unneeded here (#220).

    !end-bullet!
-   !begin-bullet!
    `rdunif()` checks its inputs for validity (#211).

    !end-bullet!
-   !begin-bullet!
    `set_names()` can now take a function to tranform the names
    programmatically (#276), and you can supply names in `...` to reduce
    typing even more more (#316). `set_names()` is now powered by
    `rlang::set_names()`.

    !end-bullet!
-   !begin-bullet!
    `safely()` now actually uses the `quiet` argument (#296).

    !end-bullet!
-   !begin-bullet!
    `transpose()` now matches by name if available (#164). You can
    override the default choice with the new `.names` argument.

    !end-bullet!
-   !begin-bullet!
    The function argument of `detect()` and `detect_index()` have been
    renamed from `.p` to `.f`. This is because they have mapper
    semantics rather than predicate semantics.

    !end-bullet!

!end-bullets-39!

# purrr 0.2.2.1

This is a compatibility release with dplyr 0.6.0.

!begin-bullets-40!

-   !begin-bullet!
    All data-frame based mappers have been removed in favour of new
    functions and idioms in the tidyverse. `dmap()`, `dmap_at()`,
    `dmap_if()`, `invoke_rows()`, `slice_rows()`, `map_rows()`,
    `by_slice()`, `by_row()`, and `unslice()` have been moved to
    purrrlyr. This is a bit of an aggresive change but it allows us to
    make the dependencies much lighter.
    !end-bullet!

!end-bullets-40!

# purrr 0.2.2

!begin-bullets-41!

-   !begin-bullet!
    Fix for dev tibble support.

    !end-bullet!
-   !begin-bullet!
    `as_function()` now supports list arguments which allow recursive
    indexing using either names or positions. They now always stop when
    encountering the first NULL (#173).

    !end-bullet!
-   !begin-bullet!
    `accumulate` and `reduce` correctly pass extra arguments to the
    worker function.

    !end-bullet!

!end-bullets-41!

# purrr 0.2.1

!begin-bullets-42!

-   !begin-bullet!
    `as_function()` gains a `.null` argument that for character and
    numeric values allows you to specify what to return for null/absent
    elements (#110). This can be used with any map function,
    e.g. `map_int(x, 1, .null = NA)`

    !end-bullet!
-   !begin-bullet!
    `as_function()` is now generic.

    !end-bullet!
-   !begin-bullet!
    New `is_function()` that returns `TRUE` only for regular functions.

    !end-bullet!
-   !begin-bullet!
    Fix crash on GCC triggered by `invoke_rows()`.

    !end-bullet!

!end-bullets-42!

# purrr 0.2.0

## New functions

!begin-bullets-43!

-   !begin-bullet!
    There are two handy infix functions:

    !begin-bullets-44!
    -   !begin-bullet!
        `x %||% y` is shorthand for `if (is.null(x)) y else x` (#109).
        !end-bullet!
    -   !begin-bullet!
        `x %@% "a"` is shorthand for `attr(x, "a", exact = TRUE)` (#69).
        !end-bullet!

    !end-bullets-44!
    !end-bullet!
-   !begin-bullet!
    `accumulate()` has been added to handle recursive folding. It is
    shortand for `Reduce(f, .x, accumulate = TRUE)` and follows a
    similar syntax to `reduce()` (#145). A right-hand version
    `accumulate_right()` was also added.

    !end-bullet!
-   !begin-bullet!
    `map_df()` row-binds output together. It's the equivalent of
    `plyr::ldply()` (#127)

    !end-bullet!
-   !begin-bullet!
    `flatten()` is now type-stable and always returns a list. To return
    a simpler vector, use `flatten_lgl()`, `flatten_int()`,
    `flatten_dbl()`, `flatten_chr()`, or `flatten_df()`.

    !end-bullet!
-   !begin-bullet!
    `invoke()` has been overhauled to be more useful: it now works
    similarly to `map_call()` when `.x` is NULL, and hence `map_call()`
    has been deprecated. `invoke_map()` is a vectorised complement to
    `invoke()` (#125), and comes with typed variants `invoke_map_lgl()`,
    `invoke_map_int()`, `invoke_map_dbl()`, `invoke_map_chr()`, and
    `invoke_map_df()`.

    !end-bullet!
-   !begin-bullet!
    `transpose()` replaces `zip2()`, `zip3()`, and `zip_n()` (#128). The
    name more clearly reflects the intent (transposing the first and
    second levels of list). It no longer has fields argument or the
    `.simplify` argument; instead use the new `simplify_all()` function.

    !end-bullet!
-   !begin-bullet!
    `safely()`, `quietly()`, and `possibly()` are experimental functions
    for working with functions with side-effects (e.g. printed output,
    messages, warnings, and errors) (#120). `safely()` is a version of
    `try()` that modifies a function (rather than an expression), and
    always returns a list with two components, `result` and `error`.

    !end-bullet!
-   !begin-bullet!
    `list_along()` and `rep_along()` generalise the idea of
    `seq_along()`. (#122).

    !end-bullet!
-   !begin-bullet!
    `is_null()` is the snake-case version of `is.null()`.

    !end-bullet!
-   !begin-bullet!
    `pmap()` (parallel map) replaces `map_n()` (#132), and has
    typed-variants suffixed `pmap_lgl()`, `pmap_int()`, `pmap_dbl()`,
    `pmap_chr()`, and `pmap_df()`.

    !end-bullet!
-   !begin-bullet!
    `set_names()` is a snake-case alternative to `setNames()` with
    stricter equality checking, and more convenient defaults for pipes:
    `x |> set_names()` is equivalent to `setNames(x, x)` (#119).

    !end-bullet!

!end-bullets-43!

## Row based functionals

We are still figuring out what belongs in dplyr and what belongs in
purrr. Expect much experimentation and many changes with these
functions.

!begin-bullets-45!

-   !begin-bullet!
    `map()` now always returns a list. Data frame support has been moved
    to `map_df()` and `dmap()`. The latter supports sliced data frames
    as a shortcut for the combination of `by_slice()` and `dmap()`:
    `x |> by_slice(dmap, fun, .collate = "rows")`. The conditional
    variants `dmap_at()` and `dmap_if()` also support sliced data frames
    and will recycle scalar results to the slice size.

    !end-bullet!
-   !begin-bullet!
    `map_rows()` has been renamed to `invoke_rows()`. As other
    rows-based functionals, it collates results inside lists by default,
    but with column collation this function is equivalent to
    `plyr::mdply()`.

    !end-bullet!
-   !begin-bullet!
    The rows-based functionals gain a `.to` option to name the output
    column as well as a `.collate` argument. The latter allows to
    collate the output in lists (by default), on columns or on rows.
    This makes these functions more flexible and more predictable.

    !end-bullet!

!end-bullets-45!

## Bug fixes and minor changes

!begin-bullets-46!

-   !begin-bullet!
    `as_function()`, which converts formulas etc to functions, is now
    exported (#123).

    !end-bullet!
-   !begin-bullet!
    `rerun()` is correctly scoped (#95)

    !end-bullet!
-   !begin-bullet!
    `update_list()` can now modify an element called `x` (#98).

    !end-bullet!
-   !begin-bullet!
    `map*()` now use custom C code, rather than relying on `lapply()`,
    `mapply()` etc. The performance characteristcs are very similar, but
    it allows us greater control over the output (#118).

    !end-bullet!
-   !begin-bullet!
    `map_lgl()` now has second argument `.f`, not `.p` (#134).

    !end-bullet!

!end-bullets-46!

## Deprecated functions

!begin-bullets-47!

-   !begin-bullet!
    `flatmap()` -\> use `map()` followed by the appropriate `flatten()`.

    !end-bullet!
-   !begin-bullet!
    `map_call()` -\> `invoke()`.

    !end-bullet!
-   !begin-bullet!
    `map_n()` -\> `pmap()`; `walk_n()` -\> `pwalk()`.

    !end-bullet!
-   !begin-bullet!
    `map3(x, y, z)` -\> `map_n(list(x, y, z))`;
    `walk3(x, y, z) ->`pwalk(list(x, y, z))\`

    !end-bullet!

!end-bullets-47!
